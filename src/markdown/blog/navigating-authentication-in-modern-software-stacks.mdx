---
path: '/navigating-authentication-in-modern-software-stacks/'

title: |
  Navigating Authentication in Modern Software Stacks

teaser: |
  Cookies and Tokens, which one do you need?

seo:
  title: |
    Navigating Authentication in Modern Software Stacks
  description: |
    This guide will go through what Authentication is and how to effectively use it in your software stack
  keywords: |
    auth, modern software stack, authentication, tokens, cookies, OAuth2.0

published: true

publishedAt: '2022-03-03'

author: benehiko

overline: |
  Modern Application Architecture

tags:
  - Guide
  - Architecture
  - Authentication
---

## Preface

Auth, although important, always intrudes in the development process of
software. As a software developer you probably have noticed a lot of precious
development time is taken to add Auth to a project. This is usually because of
so many terminology, navigating a sea of contradicting resources on what is the
_most secure_ way of implementing Auth. Is it using Tokens such as JWTs?
OAuth2.0? or Cookies?, the list goes on.

Furthermore, when working on different stacks we have different requirements for
User Experience (UX) and sometimes AuthN just gets in the way of that.

Hopefully this article will clarify some of that confusion and allow you to
focus on your applications' business logic.

## Terminology

If you are already familiar with Authentication, Authorization and Sessions you
can skip ahead to [The Modern Stack](./#the-modern-stack) section.

### Authentication & Authorization

Before we go any further with this article we first need to clarify what Auth we
are talking about. There are two types, Authentication (AuthN) and Authorization
(AuthZ).

Here are the definitions:

> Authentication: The process of verifying that an identity (person, device,
> program) is who they say they are

> Authorization: The process of validating if an identity (person, device,
> program) is allowed to access a resource or perform a certain action on a
> resource.

For further reference, see these Stack Overflow posts:

- https://stackoverflow.com/questions/6556522/authentication-versus-authorization
- https://stackoverflow.com/questions/6367865/is-there-a-difference-between-authentication-and-authorization

To put it simply, when adding login to our Application, we are talking about
Authentication and when we are talking about who can do what on our Application,
we are talking about Authorization.

### Sessions

Now that we know what AuthN is, let's dive deeper by investigating all the
aspects of how AuthN works. With the use of a simple diagram, we can see the
user supplies their credentials to Project X which then validates the
credentials with the Database.

![Simple Authentication](media/authentication-flow.png)

What this diagram is missing is how do we ensure the user does not need to
provide their credentials every time the user navigates to another page or does
an action. I'm sure you have heard of the term _session_. A session just means
we have created a mechanism to store information about the user in our
application, in AuthN we can use this mechanism for users to always prove they
are who they say they are without needing their credentials. So is a session
then some sort of cookie or token? Well depending on the technology or use case,
a session can be a query parameter in the URL, a cookie storing some
information, the browser's local storage or a token.

## The Modern Stack

In our current software climate we have the requirement to support as many
devices as possible through a single codebase, or at least in as few as
possible. This gives us the ability to maintain the software, add new features
and (hopefully) increase our user adoption.

However, through all of this we have ended up dealing with a lot of frameworks,
which creates a lot of abstraction. Although frameworks save us time when
implementing a feature, it can also happen that the framework just does not
support the underlying requirements for the feature. This can even be the case
when dealing with AuthN, some technologies do not provide clarity on how AuthN
fits in without breaking the User Experience (UX).

Furthermore, when looking at different AuthN terminology and setting up an
application using _the modern stack_, we end up with a lot of questions. Can I
use a cookie here? Why would it be better for a token here? I have even seen
articles proclaim OAuth2.0 as the **next security standard for your Web App**
without any context of its correct usage. This article will not address OAuth2,
if you are interested, please take a look at the article
[Why you probably do not need OAuth2 / OpenID Connect](/oauth2-openid-connect-do-you-need-use-cases-examples/).

For us to understand the problems of AuthN and their solutions, we must first
understand the underlying elements at play when working with a certain
technology.

If you are already familiar with SPAs, SSRs and Native Apps, you can skip ahead
to [The Problem](./#the-problem) section.

### Single Page Applications (SPA)

Single Page applications run completely on the client's browser and do not rely
on any server interaction to keep the state of your data.
[React](https://reactjs.org/), [Angular](https://angular.io/),
[VueJs](https://vuejs.org/), etc. are examples of SPAs. If you have had any
experience writing SPAs you would have noted that they run solely in the
browser, basically HTML, CSS and JavaScript. Even when dealing with
[Electron](https://www.electronjs.org/) and
[Progressive Web Apps (PWA)](https://web.dev/progressive-web-apps/) installs,
everything is running through the browser.

![SPA Diagram](media/spa-diagram.png)

### Server-Side Rendering (SSR) Applications

Server-side rendered applications solve a different problem, however, they
usually build upon the already existing SPA stack. The goal is for the
application to render the pages on the server before they reach the client. This
improves page load times since the client does not need to download all the
JavaScript assets before the first content is displayed. Some examples of
frameworks that allow for SSR are [NextJs](https://nextjs.org/),
[NuxtJs](https://v3.nuxtjs.org/)

![SSR Diagram](media/ssr-diagram.png)

### Native Applications

Applications that run on Android, iOS, Desktop and Server are all forms of
Native Applications. These applications usually provide native performance and
utilizes the Operating System to render the User Interface (UI).

Examples of Frameworks that allow for Native Application development are
[Android](https://developer.android.com/), [iOS](https://developer.apple.com/)
and [.NET](https://dotnet.microsoft.com/).

Command Line Interface (CLI) Applications executed using a terminal or command
line on the Operating System also fall into the category of Native Applications
and can be built using [Go](https://go.dev/), [C++](https://isocpp.org/),
[Python](https://www.python.org/), [NodeJs](https://nodejs.org/) etc.

## The Problem

Each technology behaves differently in their respective contexts and thus
requires a different solution when trying to implement AuthN. From the above
list of technologies we can see that we can more or less split the technologies
into applications that run on the user device and those that run on controlled
infrastructure, e.g. a server. This can be further split into **server-side**,
**browsers** and **native**.

### Browsers

Browser rendered applications have a myriad of sources on AuthN all of which
cause confusion since many blogs and sources advocate the usage of a different
technologies to solve _sessions_.

The list looks something like this:

- JWT tokens
- OAuth2 access tokens
- Cookies

To understand the limitations of browsers and the security concerns that go with
it, let's take a look at the different storage mechanisms a browser offers:

| Storage Type             | Cookie (httpOnly) | sessionStorage | localStorage | Web Workers |
| ------------------------ | ----------------- | -------------- | ------------ | ----------- |
| Persists                 | ✅                | ❌             | ✅           | ✅          |
| Origin Scoped            | ✅                | ✅             | ❌           | ✅          |
| Accessible to JavaScript | ❌                | ✅             | ✅           | ✅          |

We will use Alice as an example to explain the drawbacks of each storage type.

Alice visits `example.com` and gets some sort of token stored in her Browsers.
With `localStorage` any other website she visits (e.g. `evil.com`) can extract
that information (using JavaScript) and try to impersonate her on `example.com`.

Furthermore, `sessionStorage` scopes the data which means that the origin
`example.com` can only access `example.com` data (using JavaScript), but does
not persist. So once the tab/window is closed, the token is gone!

With `cookies` - note the `httpOnly` attribute - we get persistence (until
expiry), origin scope and no JavaScript access.

Web Workers are unique in that they scope the data to the origin `example.com`
and provide JavaScript access and the storage persists.

So I guess it's settled then? Web Workers are the way to go?

Well yes and no. Quoting from the
[OWASP Session Management Cheat sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#web-workers):

> The advantage of a Web Worker implementation compared to an HttpOnly cookie is
> that a Web Worker allows for some isolated JavaScript code to access the
> secret; an HttpOnly cookie is not accessible to any JavaScript. If the
> frontend JavaScript code requires access to the secret, the Web Worker
> implementation is the only browser storage option that preserves the secret
> confidentiality.

This is a niche case, most of the time we do not require any JavaScript to
access the secret (session value). On top of this **we are then responsible** to
not introduce any bugs that could leak the secret. That is where cookies come
in.

The interesting part about cookies are that they provide all the features we
want for `session` storage minus the headache of managing them, **they are
managed for us by the browser**. They persist after tabs/windows close (until
their expiry date) and are scoped to the origin. We can even ensure they are not
transmitted over unsecure channels by using the `Secure` attribute. Since the
browser is managing the cookie, it **decreases the risk** of a security
vulnerability accidentally leaking the session.

If you want to know more about cookies and their attributes, I would strongly
suggest checking out
[OWASP Testing Cookies](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing/02-Testing_for_Cookies_Attributes).

To understand more about the vulnerabilities associated with JavaScript and
Cross Site Scripting (XSS) please refer to the
[OWASP XSS](https://owasp.org/www-community/attacks/xss/) document.

### Server-Side and Native

These technologies do have their own set of problems, however, they are
_usually_ easier in storing sensitive information since the environment they run
in is by definition more secure. This of course does rely on your security
practices, such as who has access to your servers and how you configure access
from the outside.

But let's say for argument’s sake the environment is secure, then tokens can
easily be issued to a server and kept in-memory - it is not needed to store on
disk since, hopefully, your server does not restart every couple of hours ;)

On mobile Android and iOS each have their own methodology of storing Tokens, but
it comes down to the same concept, these systems inherently do not share storage
through e.g. Shared Preferences (on Android) with other Apps on the device.

## Conclusion

There is no silver bullet in security that will fix all of our problems. But by
relying on good resources, such as [OWASP](https://owasp.org) we can better
understand how to navigate security pitfalls.

With that said, it all boils down to your use case and using a token such as a
JWT or a cookie mostly relies on your use case. With
[Ory Kratos](https://www.ory.sh/kratos) we decided to stick with cookies
(httpOnly) when **using a Browser** and tokens when **using a Native
Application**.

### Sources

- [PWA standard](https://infrequently.org/2015/06/progressive-apps-escaping-tabs-without-losing-our-soul/)
- [Progressive Web Apps (PWA)](https://web.dev/progressive-web-apps/)
- [Angular](https://angular.io/)
- [Electron](https://www.electronjs.org/)
- [VueJs](https://vuejs.org/)
- [OWASP HTML5 storage cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#html5-web-storage-api)
- [OWASP Testing Browser Storage](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/11-Client-side_Testing/12-Testing_Browser_Storage)
- [OWASP Testing Cookies](https://owasp.org/www-project-web-security-testing-guide/stable/4-Web_Application_Security_Testing/06-Session_Management_Testing/02-Testing_for_Cookies_Attributes)
- [OWASP Session management cheatsheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html#session-management-implementation)
