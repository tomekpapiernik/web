---
templateKey: blog
path: '/building-url-shortener-using-cloud-services-backend/'
author: gen1us2k
title: Building url shortener project using Supabase database and Ory Cloud
teaser: Building todo list API using ready-to-use solutions
subtitle: Step-by-step guide to create urlshortener with authentication using Cloud solutions
overline: Ory Cloud and Supabase guide
publishedAt: 2022-03-15
published: true
description: ''
tags:
  - Guide
  - Authentication
  - Ory Cloud
  - Open Source
  - User Management
---

import CodeFromRemote from '../../components/freestanding/utils/codefromremote'

One can save time by using ready solutions to build a completely new product. Many startups solve one problem and do it best. For instance, we have at least three cloud providers to host our code. We have multiple choices on what to choose to build a frontend for our next project. At least we have vue.js and react.js projects with broad communities.
In this article, I'll show you an example of how to build an URL shortener using a modern technology stack.

You can find complete project [here](https://github.com/gen1us2k/shorts)

## What technologies do we use in this example

[Ory Kratos](https://www.ory.sh/kratos/docs/) to manage identities and users. We'll use an open source self-hosted version in this article, but consider using [Ory Cloud](https://ory.sh/docs/cloud) in the production.

[Supabase](https://supabase.com) is the opensource alternative of firebase. Supabase Database comes with a full [Postgres](https://www.postgresql.org/) database, a free and open-source database that is considered one of the world's most stable and advanced databases. We'll use Supabase as Database for our url shortener project

[Ory Oathkeeper](https://www.ory.sh/docs/oathkeeper) would be a great example of applying Zero Trust architecture for our project. We'll use it as Identity and access proxy.

[Migrate](https://github.com/golang-migrate/migrate) to perform database migrations

[Postgres](https://www.postgresql.org/) is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.



## A short explanation about backend choices

I'm a huge fan of the Go programming language, and I've been coding using this language since late 2014. I love the simplicity of Go language design and the ecosystem around it. Why to Go

- It's good to perform static code analysis to make your backend systems more robust and stable. GolangCI-lint is a feature-rich linter that gives you feedback about your code. You can find a lot of linters available.
- Strongly typed programming language with static data types. One does not need to write tests to check that your code will never mess with data types. `int i' makes `i' int forever.
- It's easy to follow SOLID principles and clear architecture using Go.
- In addition, Go is fast and well-scaled programming language

### Database migrations

Database migrations should be used once you use any RDMBS in your project because you need to change database schema time-to-time. It helps you track versions of your schema and easily perform forwards and downwards migrations. In the pythonic world, it's easy to decide what tool to use for schema migration because it's usually come out of the box by the selected framework. For instance, we have flask-migrate for flask and Django migrations for Django. Since Go uses UNIX philosophy to build the architecture of your project, you need to choose

- HTTP router for your endpoints
- ORM or a library to work with the database
- a tool to perform migrations

Go programming language has at least two tools for schema migrations. I used both goose and migrate, and in this project, I decided to go with migrate. Migrate supports more databases, and I want to make the DB layer in this project database agnostic.

My requirements for Go migration tool:

1. Plain SQL migrations support. I don't want to learn an additional filetype format. I know SQL and I know how to create tables. That's enough. Unlike Django Go does not have any good Active Record pattern implementations. I hope that there will be more ORMs and better tooling once Go 1.18 released (Generics are on the way).
2. Support of opensource RDBMS like Postgres, MySQL (and all their forks), Oracle (but I don't use it yet)
3. Programmable API or shorthanded way to apply migrations
4. Upward/Downward support


### Gin.

A URL shortener is a lightweight service, and it would be best to have a simple enough package to build an HTTP API around it. You  have several options on what to choose to solve this issue, and the most popular frameworks are

- [Echo](https://echo.labstack.com)
- [Gin](https://github.com/gin-gonic/gin)
- [Go-kit](https://github.com/go-kit/kit)

Go-kit is an excellent framework for building a complex system with many microservices. Even a simple net/http with http router would be enough for our example. Usually, I toss a coin when I choose between echo and gin, so I use gin in this project.

I'm huge fan of gRPC when I build APIs with Go and I used it a lot in my previous experience. Also, I'm huge fan of echo framework. I chose gin because of it's simplicity and feature rich support. Actually a simple `net/http` would be enough to build this project with httprouter but to make things more conveinent I chose gin.

Okay. Let's start hacking, shall we?

## Configuration package

<CodeFromRemote
  src="https://github.com/gen1us2k/shorts/blob/master/cmd/shorts/main.go"
  lang="golang"
/>

## Defining Database schema.

The URL shortener should have the following tables:

- `url` table to store shortened URLs
- `url_view` table to store views. This information will be useful to build additional reports for users about top referrers, urlviews or something else.

```sql
CREATE TABLE IF NOT EXISTS url (
	id SERIAL PRIMARY KEY,
	url VARCHAR(255) NOT NULL DEFAULT '',
	hash varchar(10) NOT NULL DEFAULT '',
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	expired_at TIMESTAMP WITH TIME ZONE,
	owner_id VARCHAR(36) NOT NULL DEFAULT ''
);

CREATE UNIQUE INDEX idx_url_hash ON url(hash);

CREATE TABLE IF NOT EXISTS url_view (
	id SERIAL PRIMARY KEY,
	referer VARCHAR(255) NOT NULL DEFAULT '',
	url_id INT NOT NULL,
	CONSTRAINT fk_url_view FOREIGN KEY(url_id) REFERENCES url(id)
);
```

## Creating supabase project and tables


- From your [Supabase dashboard](https://app.supabase.io/) , click `New project`.
- Enter a `Name` for your Supabase project.
- Enter a secure `Database Password`.
- Select `Region` you want.
- Click Create new project.

![Create Project](./media/supabase/supabase-create-project.png)

- Open table editor
- Click on `SQL editor` on sidebar
- Insert SQL table definition from the previous step
- Click Run to create tables

![Create tables](./media/supabase/supabase-create-table.png)

## Designing the Database

I always use interfaces for database layer because of the following benefits

- I can change a database simply by implementing a designed interface
- It helps me to think and design a proper layer for the database
- It helps to reduce dependencies between different parts of the codebase
- It helps to write more modular and decoupled code
- I can always implement a mock for my database layer by simply implementing a mock layer and use it in tests

<CodeFromRemote
  src="https://github.com/gen1us2k/shorts/blob/master/database/database.go"
  lang="golang"
/>

## Implementing the Database
Supabase uses Postgres as their main RDBMS. Also, they use PostgREST, a standalone web server that turns your PostgreSQL database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations.
Here's the supabase implementation of database layer.

<CodeFromRemote
  src="https://github.com/gen1us2k/shorts/blob/master/database/supabase.go"
  lang="golang"
/>

## Designing the HTTP API

Url shortener is a simple project and we need only two endpoints:

- Shortify URL by passing POST request to /api/url
- Get created URLs by passing GET request to /api/url endpoint

Here's the implementation

<CodeFromRemote
  src="https://github.com/gen1us2k/shorts/blob/master/api/api.go"
  lang="golang"
/>

## Building everything together

Create a file in `cmd/shorts/main.go` with the following content

<CodeFromRemote
  src="https://github.com/gen1us2k/shorts/blob/master/config/config.go"
  lang="golang"
/>

## Configuring oathkeeper

I'll use oathkeeper in this example to have zero trust network configuration. Oathkeeper, in this example, acts as a reverse proxy, but it checks if the request is authenticated.

URLs that follow `/u/hash`  pattern should be available for anonymous users, and API should be available only for authenticated users.
Here's the basic configuration for oathkeeper

<CodeFromRemote
  src="https://github.com/gen1us2k/shorts/blob/master/oathkeeper/oathkeeper.yml"
  lang="yaml"
/>

Access rules for oathkeeper

<CodeFromRemote
  src="https://github.com/gen1us2k/shorts/blob/master/oathkeeper/access-rules.yml"
  lang="yaml"
/>

## Dealing with authentication
You can follow the [quickstart guide](https://www.ory.sh/docs/kratos/quickstart) to add Kratos to your project. You can inspect [docker-compose]( and kratos folder in the repository, but I have a basic configuration taken from a quickstart.

## Authentication middleware

<CodeFromRemote
  src="https://github.com/gen1us2k/shorts/blob/master/middleware/middleware.go"
  lang="go"
/>

## Further steps

- Enable [2FA](https://www.ory.sh/docs/kratos/guides/two-factor-authentication-2fa-mfa) for Ory kratos
- Add support of AWS Lambda for backend to enable cost-effective hosting
- Integrate frontend for the application (it'll be in the next blogpost)
